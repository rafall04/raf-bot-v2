"use strict";

/**
 * RAF Bot Message Handler - Refactored Version
 * Main message handler yang telah direfactor untuk modularitas yang lebih baik
 */

// === CORE MODULES ===
const fs = require("fs");
const path = require("path");
const axios = require('axios');
const { exec } = require('child_process');

// === EXTERNAL LIBRARIES ===
const convertRupiah = require('rupiah-format');
const qr = require('qr-image');

// === LIB MODULES ===
const { color, bgcolor } = require("../lib/color");
const { getBuffer, fetchJson, fetchText, getRandom, getGroupAdmins, runtime, sleep, convert, convertGif, html2Txt } = require("../lib/myfunc");
const { wifimenu, menupaket, menubelivoucher, menupasang, menuowner, customermenu, techinisionmenu, menuvoucher } = require("./wifi");
const { getPppStats, getHotspotStats, statusap, getvoucher, addpppoe, addbinding, addqueue } = require("../lib/mikrotik");
const { addvoucher, checkhargavc, checkprofvc, checkhargavoucher, checknamavc, checkdurasivc, checkprofvoucher, delvoucher } = require("../lib/voucher");
const { addStatik, checkLimitAt, checkMaxLimit, checkStatik, delStatik } = require("../lib/statik");
const { addATM, addKoinUser, checkATMuser, confirmATM, checkRegisteredATM, delSaldo } = require("../lib/saldo");
// DISABLED - Using new conversation flow
// // REMOVED: Old saldo handler import
const saldoManager = require('../lib/saldo-manager');
const conversationHandler = require('./handlers/conversation-handler');
const { addPayment } = require("../lib/payment");
const { getIntentFromGemini, getConversationalResponse } = require("../lib/gemini");
const { getIntentFromKeywords } = require('../lib/wifi_template_handler');
const { templatesCache } = require("../lib/templating");
const { savePackageChangeRequests, saveSpeedRequests } = require("../lib/database");
const pay = require("../lib/ipaymu");
const commandManager = require('../lib/command-manager');
const messageManager = require('../lib/message-manager');

// === MONITORING & SECURITY MODULES ===
const { logger } = require("../lib/logger");
const { sendErrorResponse, ErrorType } = require("../lib/error-response");
const { checkRateLimit } = require("../lib/rate-limiter");
const { trackCommand, trackUser, trackError, startTimer } = require("../lib/metrics");

// === HANDLER MODULES ===
const { 
    getUserState, 
    setUserState, 
    deleteUserState, 
    hasActiveState, 
    mess, 
    format 
} = require('./handlers/conversation-handler');

const { 
    handleReportCreation, 
    handleTicketCheck, 
    handleTicketCancellation,
    generateTicketId,
    saveReportsToFile
} = require('./handlers/report-handler');

// Use wifi-handler-fixed for ALL WiFi operations (has conversation flow)
const {
    handleWifiNameChange,
    handleWifiPasswordChange,
    handleWifiInfoCheck,
    handleRouterReboot,
    handleWifiPowerChange
} = require('./handlers/wifi-handler-fixed');

const {
    handleWifiHistory,
    handleQuickWifiInfo
} = require('./handlers/wifi-history-handler');

const { 
    handlePaymentRequest, 
    checkPaymentRequestStatus 
} = require('./handlers/payment-handler');

const { 
    handlePppStats, 
    handleHotspotStats, 
    handleListUsers, 
    handleSearchUser, 
    handleReportList 
} = require('./handlers/admin-handler');

const { 
    handleCheckBill, 
    handleCheckPackage, 
    handlePaymentConfirmation, 
    handleComplaint, 
    handleServiceInfo 
} = require('./handlers/customer-handler');

const {
    handleSpeedPaymentProof,
    handleSpeedRequestStatus,
    getUserPendingSpeedRequest
} = require('./handlers/speed-payment-handler');

const {
    handleSpeedBoostRequest,
    handleSpeedBoostConversation,
    clearSpeedBoostStatus
} = require('./handlers/speed-boost-handler');

const {
    checkSpeedBoostStatus
} = require('./handlers/speed-status-handler');

const { 
    extractPhoneNumber, 
    formatToJID, 
    findUserByPhone, 
    findUserByDeviceId, 
    isAdmin, 
    isTeknisi: isTeknisiUtil,
    isValidDeviceId, 
    formatDateIndonesian, 
    parseCommand, 
    cleanPhoneNumber, 
    isFromGroup 
} = require('./handlers/utils');

const { handleConversationStep } = require('./handlers/steps');

// === SALDO & TOPUP HANDLERS ===
const {
    handleCekSaldo,
    handleTopupInit,
    handleCancelTopup,
    handleBeliVoucher,
    handleTransferSaldo
} = require('./handlers/saldo-handler');

const {
    handleTopupPaymentProof
} = require('./handlers/topup-handler');

// === UNIFIED AGENT HANDLER ===
// Consolidates: agent-handler, agent-transaction-handler, agent-self-service-handler
const {
    // Customer commands
    handleListAgents,
    handleAgentByArea,
    handleAgentServices,
    handleSearchAgent,
    handleViewAgentDetail,
    // Agent transactions
    handleAgentConfirmation,
    handleAgentTodayTransactions,
    handleCheckTopupStatus,
    // Agent self-service
    handleAgentPinChange,
    handleAgentProfileUpdate,
    handleAgentStatusToggle,
    handleAgentSelfProfile
} = require('./handlers/agent');

// === GLOBAL CONFIG ===
let { ownerNumber } = global.config;

// === MAIN MODULE EXPORT ===
module.exports = async(raf, msg, m) => {
    const { generateWAMessageFromContent, prepareWAMessageMedia, proto } = await import('@whiskeysockets/baileys');

    // === MESSAGE VALIDATION ===
    if (((msg.key.id.startsWith("BAE5") && msg.key.id.length < 32) || 
         (msg.key.id.startsWith("3EB0") && msg.key.id.length < 32)) && 
         msg.key?.fromMe) return;

    // === PERFORMANCE TRACKING ===
    const messageTimer = startTimer('message_processing');

    // === EXTRACT MESSAGE INFO ===
    const from = msg.key.remoteJid;
    const type = Object.keys(msg.message)[0];
    const chats = (type === 'conversation' && msg.message.conversation) ? 
                  msg.message.conversation : 
                  (type == 'imageMessage') && msg.message.imageMessage.caption ? 
                  msg.message.imageMessage.caption : 
                  (type == 'documentMessage') && msg.message.documentMessage.caption ? 
                  msg.message.documentMessage.caption : 
                  (type == 'videoMessage') && msg.message.videoMessage.caption ? 
                  msg.message.videoMessage.caption : 
                  (type == 'extendedTextMessage') && msg.message.extendedTextMessage.text ? 
                  msg.message.extendedTextMessage.text : 
                  (type == 'buttonsResponseMessage' && msg.message.buttonsResponseMessage.selectedButtonId) ? 
                  msg.message.buttonsResponseMessage.selectedButtonId : 
                  (type == 'templateButtonReplyMessage') && msg.message.templateButtonReplyMessage.selectedId ? 
                  msg.message.templateButtonReplyMessage.selectedId : 
                  msg.message?.interactiveResponseMessage?.nativeFlowResponseMessage ? 
                  (JSON.parse(msg.message.interactiveResponseMessage.nativeFlowResponseMessage?.paramsJson || '{}')?.id || '') : "";

    // === BASIC MESSAGE PARSING ===
    const args = chats.split(' ');
    const command = chats.toLowerCase().split(' ')[0] || '';
    const q = chats.slice(command.length + 1, chats.length);
    const pushname = msg.pushName || "No Name";
    const sender = msg.key.remoteJid;
    const senderNumber = extractPhoneNumber(sender);
    const isGroup = isFromGroup(sender);
    
    // === USER IDENTIFICATION ===
    const isOwner = isAdmin(sender);
    const isTeknisi = isTeknisiUtil(sender);
    
    // Check if user is an agent
    const agentManager = require('../lib/agent-manager');
    const agent = agentManager.getAgentByWhatsapp(sender);
    const isAgent = agent ? true : false;
    
    // Determine user role
    const userRole = isOwner ? 'owner' : isTeknisi ? 'teknisi' : isAgent ? 'agent' : 'customer';
    
    // Log agent detection for debugging
    if (isAgent) {
        logger.debug('Agent detected', {
            agentId: agent.id,
            agentName: agent.name,
            sender: sender,
            role: userRole
        });
    }

    // === TRACK USER ACTIVITY ===
    trackUser(sender, 'message');

    // === RATE LIMITING CHECK ===
    const rateLimitResult = checkRateLimit(sender, { role: userRole });
    if (!rateLimitResult.allowed) {
        logger.warn(`Rate limit exceeded for user: ${sender}`);
        trackUser(sender, 'error');
        return raf.sendMessage(from, { text: rateLimitResult.message }, { quoted: msg });
    }
    
    // Show warning if approaching limit
    if (rateLimitResult.warning) {
        raf.sendMessage(from, { text: rateLimitResult.warning });
    }

    // === HELPER FUNCTIONS ===
    const reply = async (text) => {
        try {
            await raf.sendMessage(from, { text }, { quoted: msg });
        } catch (error) {
            logger.error('Failed to send reply', { error, to: from });
        }
    };

    const sendImage = async (url, caption) => {
        const media = await prepareWAMessageMedia({ image: { url } }, { upload: raf.waUploadToServer });
        await raf.sendMessage(from, { image: media.image, caption }, { quoted: msg });
    };

    const sendDocument = async (path, filename, caption) => {
        await raf.sendMessage(from, {
            document: { url: path },
            fileName: filename,
            caption: caption
        }, { quoted: msg });
    };

    // === CHECK FOR PAYMENT PROOF UPLOADS ===
    if ((type === 'imageMessage' || type === 'documentMessage') && !isGroup) {
        const user = findUserByPhone(senderNumber);
        if (user) {
            // Check for pending speed request
            const pendingRequest = getUserPendingSpeedRequest(user.id);
            if (pendingRequest) {
                logger.info('Processing speed request payment proof', { 
                    userId: user.id, 
                    requestId: pendingRequest.id 
                });
                
                await handleSpeedPaymentProof(msg, user);
                messageTimer();
                return;
            }
            
            // Check for pending topup request
            const pendingTopupRequests = saldoManager.getUserTopupRequests(sender)
                .filter(r => r.status === 'pending' && r.paymentMethod === 'transfer' && !r.paymentProof);
            
            if (pendingTopupRequests.length > 0) {
                logger.info('Processing topup payment proof', { 
                    userId: user.id, 
                    requestId: pendingTopupRequests[0].id 
                });
                
                await handleTopupPaymentProof(msg, user, pushname);
                messageTimer();
                return;
            }
        }
    }

    // === CHECK FOR ACTIVE CONVERSATION STATE ===
    const userState = getUserState(sender);
    
    // Check if user wants to cancel topup BEFORE processing conversation state
    const lowerChats = chats.toLowerCase().trim();
    if (lowerChats === 'batal topup' || lowerChats === 'cancel topup' || lowerChats === 'batalkan topup') {
        await handleCancelTopup(msg, sender, reply);
        // Clear any conversation state if exists
        if (userState) {
            deleteUserState(sender);
        }
        messageTimer();
        return;
    }
    
    if (userState && userState.step) {
        // Handle other multi-step conversations
        const result = await handleConversationStep({
            userState,
            sender,
            chats,
            pushname,
            reply,
            setUserState,
            deleteUserState
        });
        
        if (result.message) {
            return reply(result.message);
        }
        return;
    }
    
    // === CHECK FOR SPEED BOOST CONVERSATION ===
    // Check if user is in speed boost conversation flow
    if (!isGroup) {
        const user = findUserByPhone(senderNumber);
        if (user) {
            const handled = await handleSpeedBoostConversation(msg, user, sender, chats);
            if (handled) {
                messageTimer();
                return;
            }
        }
    }

    // === INTENT DETECTION ===
    let intent = 'TIDAK_DIKENALI';
    let entities = {};
    let matchedKeywordLength = 0;
    let commandInfo = null;

    // Try new command manager first
    try {
        const commandResult = commandManager.getIntent(chats, userRole);
        if (commandResult && commandResult.intent) {
            intent = commandResult.intent;
            commandInfo = commandResult.command;
            matchedKeywordLength = commandResult.matchedKeyword ? commandResult.matchedKeyword.split(/\s+/).length : 0;
            logger.debug('Intent detected via command manager', { intent, command: commandInfo });
        }
    } catch (error) {
        logger.error('Command manager intent detection failed', error);
        trackError(ErrorType.SYSTEM, error, { module: 'command_manager' });
    }

    // Fallback to old keyword detection if no match
    if (intent === 'TIDAK_DIKENALI') {
        try {
            const keywordResult = getIntentFromKeywords(chats);
            if (keywordResult && keywordResult.intent) {
                intent = keywordResult.intent;
                entities = keywordResult.entities || {};
                matchedKeywordLength = keywordResult.matchedKeywordLength || 0;
                logger.debug('Intent detected via legacy keywords', { intent, entities });
            }
        } catch (error) {
            logger.error('Legacy keyword intent detection failed', error);
            trackError(ErrorType.SYSTEM, error, { module: 'keyword_detection' });
        }
    }

    // If no keyword match and Gemini is available, try AI detection
    if (intent === 'TIDAK_DIKENALI' && global.config.useGemini) {
        try {
            const aiTimer = startTimer('gemini_intent_detection');
            const aiResult = await getIntentFromGemini(chats);
            aiTimer();
            
            if (aiResult && aiResult.intent && aiResult.intent !== 'TIDAK_DIKENALI') {
                intent = aiResult.intent;
                entities = aiResult.entities || {};
                logger.debug('Intent detected via Gemini', { intent, entities });
            }
        } catch (error) {
            logger.error('Gemini intent detection failed', error);
            trackError(ErrorType.EXTERNAL_API, error, { module: 'gemini_detection' });
        }
    }

    // Legacy command mapping (will be removed after full migration)
    // This is now handled by command-manager.js
    
    // === CLEANUP ARGS AFTER INTENT DETECTION (OPTIONAL) ===
    // Provide cleaned args for handlers that want it, but keep original args available
    // Handlers can choose: use args (original with keywords) or argsClean (without keywords)
    // Example: "ganti sandi 12345678" -> args = ['ganti', 'sandi', '12345678'], argsClean = ['12345678']
    let argsClean = null;  // Default: no cleaning
    if (intent !== 'TIDAK_DIKENALI' && matchedKeywordLength > 0) {
        // Only clean for simple handlers that need it
        // Multi-step conversation handlers should use original args
        argsClean = args.slice(matchedKeywordLength);
        logger.debug('Args cleaned available', { 
            original: args, 
            cleaned: argsClean, 
            skipped: matchedKeywordLength 
        });
    }

    // === TRACK COMMAND ===
    if (intent !== 'TIDAK_DIKENALI') {
        trackCommand(intent, sender, { 
            role: userRole,
            message: chats.substring(0, 100) // Log first 100 chars only
        });
        trackUser(sender, 'command');
        logger.info(`Command executed: ${intent}`, { 
            user: sender, 
            role: userRole 
        });
    }

    // === MAIN INTENT HANDLER ===
    try {
        switch (intent) {
            // === CONVERSATION STARTERS ===
            case 'MULAI_BERTANYA': {
                setUserState(sender, { step: 'AWAITING_QUESTION' });
                await reply("Tentu, silakan. Apa yang ingin Anda tanyakan? üòä");
                break;
            }

        case 'TANYA_JAWAB_UMUM': {
            await raf.sendPresenceUpdate('composing', from);
            try {
                const answer = await getConversationalResponse(chats);
                await reply(answer);
            } catch (e) {
                logger.error('Tanya jawab umum error', e);
                trackError(ErrorType.EXTERNAL_API, e, { module: 'gemini_conversation' });
                await reply("Maaf, sepertinya AI sedang sibuk. Coba lagi beberapa saat ya.");
            } finally {
                await raf.sendPresenceUpdate('paused', from);
            }
            break;
        }

        // === ADMIN/TEKNISI FEATURES ===
        case 'statusppp': {
            if (!isOwner && !isTeknisi) return reply(mess.teknisiOrOwnerOnly);
            reply("‚è≥ Sedang mengambil statistik PPPoE, mohon tunggu...");
            const pppResult = await handlePppStats();
            reply(pppResult.message);
            break;
        }

        case 'statushotspot': {
            if (!isOwner && !isTeknisi) return reply(mess.teknisiOrOwnerOnly);
            reply("‚è≥ Sedang mengambil statistik Hotspot, mohon tunggu...");
            const hotspotResult = await handleHotspotStats();
            reply(hotspotResult.message);
            break;
        }

        case 'statusap': {
            if (!isOwner && !isTeknisi) return reply(mess.teknisiOrOwnerOnly);
            reply("‚è≥ Sedang mengambil status Access Point...");
            
            statusap()
                .then(apStatus => {
                    let replyText = `üì° *Status Access Point:*\n\n`;
                    replyText += `Total AP: *${apStatus.total || 'N/A'}*\n`;
                    replyText += `Online: *${apStatus.online || 'N/A'}*\n`;
                    replyText += `Offline: *${apStatus.offline || 'N/A'}*\n`;
                    reply(replyText);
                })
                .catch(err => {
                    console.error("[STATUS_AP_ERROR]", err);
                    reply(`üö´ Gagal mengambil status AP: ${err.message}`);
                });
            break;
        }

        case 'alluser': {
            if (!isOwner && !isTeknisi) return reply(mess.teknisiOrOwnerOnly);
            reply(`ALL USERS\n\n${global.users.map(user => 'Nama: ' + user.name + '\nNo Telepon: ' + user.phone_number.split("|").join(", ") + '\nPaket Langganan: ' + user.subscription + '\nAlamat: ' + user.address + '\nUsername PPPoE: ' + user.pppoe_username + '\nPassword PPPoE: ' + user.pppoe_password).join('\n\n')}`);
            break;
        }

        // === REPORT/TICKET FEATURES ===
        case 'LAPOR_GANGGUAN': {
            const user = findUserByPhone(sender);
            if (!user) return reply(mess.userNotRegister);
            
            const reportResult = await handleReportCreation({
                sender,
                pushname,
                userPelanggan: user,
                laporanText: entities.deskripsi_keluhan || q,
                reply
            });
            
            reply(reportResult.message);
            break;
        }

        case 'CEK_TIKET': {
            const ticketId = q || entities.ticket_id;
            if (!ticketId) {
                return reply(`‚ö†Ô∏è Mohon sertakan ID Tiket yang ingin Anda periksa.\n\n*Contoh:* cektiket ABC123`);
            }
            
            const checkResult = handleTicketCheck({
                ticketId,
                sender,
                pushname,
                isOwner,
                isTeknisi
            });
            
            reply(checkResult.message);
            break;
        }

        case 'BATALKAN_TIKET': {
            const ticketId = q || entities.ticket_id;
            if (!ticketId) {
                return reply(`‚ö†Ô∏è Mohon sertakan ID Tiket yang ingin dibatalkan.\n\n*Contoh:* bataltiket ABC123`);
            }
            
            const cancelResult = handleTicketCancellation({
                ticketId,
                sender,
                pushname,
                isOwner,
                isTeknisi
            });
            
            reply(cancelResult.message);
            break;
        }

        case 'SELESAIKAN_TIKET':
        case 'tiketdone': {
            if (!isOwner && !isTeknisi) return reply(mess.teknisiOrOwnerOnly);
            
            const ticketId = q || entities.ticket_id;
            if (!ticketId) {
                return reply(`‚ö†Ô∏è Mohon sertakan ID Tiket yang ingin diselesaikan.\n\n*Contoh:* tiketdone ABC123`);
            }
            
            const report = global.reports.find(r => r.ticketId === ticketId);
            if (!report) {
                return reply(`üö´ Tiket dengan ID *${ticketId}* tidak ditemukan.`);
            }
            
            if (report.status === 'selesai') {
                return reply(`‚ö†Ô∏è Tiket *${ticketId}* sudah diselesaikan sebelumnya.`);
            }
            
            // Update report status
            report.status = 'selesai';
            report.resolvedAt = new Date().toISOString();
            report.resolvedBy = pushname;
            
            // Save to file
            saveReportsToFile(global.reports);
            
            reply(`‚úÖ Tiket *${ticketId}* telah diselesaikan.\n\nüìã *Detail:*\n‚Ä¢ Pelanggan: ${report.pelangganName}\n‚Ä¢ Keluhan: ${report.laporanText}\n‚Ä¢ Diselesaikan oleh: ${pushname}`);
            break;
        }

        // === WIFI MANAGEMENT ===
        case 'GANTI_NAMA_WIFI': {
            const result = await handleWifiNameChange({
                sender,
                pushname,
                entities,
                args,  // Keep original for backward compatibility
                argsClean,  // New cleaned args
                q,
                matchedKeywordLength,
                isOwner,
                isTeknisi,
                reply
            });
            
            if (result.message) {
                reply(result.message);
            }
            break;
        }

        case 'GANTI_SANDI_WIFI': {
            const result = await handleWifiPasswordChange({
                sender,
                pushname,
                entities,
                args,  // Keep original for backward compatibility
                argsClean,  // New cleaned args
                q,
                matchedKeywordLength,
                isOwner,
                isTeknisi,
                reply
            });
            
            if (result.message) {
                reply(result.message);
            }
            break;
        }

        case 'CEK_WIFI': {
            const result = await handleWifiInfoCheck({
                sender,
                pushname,
                entities,
                args,
                isOwner,
                isTeknisi,
                reply
            });
            
            if (result.message) {
                reply(result.message);
            }
            break;
        }

        case 'INFO_WIFI': {
            // Quick info showing current WiFi name and password
            const result = await handleQuickWifiInfo({
                sender,
                pushname
            });
            
            if (result.message) {
                await reply(result.message);
            }
            break;
        }

        case 'HISTORY_WIFI': {
            // Show WiFi change history
            const result = await handleWifiHistory({
                sender,
                pushname,
                args,
                isOwner,
                isTeknisi
            });
            
            if (result.message) {
                await reply(result.message);
            }
            break;
        }
        
        case 'STATUS_SPEED': {
            // Check speed boost request status
            const user = findUserByPhone(senderNumber);
            if (!user) {
                await reply('‚ùå Maaf, nomor Anda tidak terdaftar dalam sistem.');
                break;
            }
            
            // Check if admin wants to check specific user
            if (isAdmin(sender)) {
                const args = chats.split(' ');
                if (args.length > 1) {
                    const targetUserId = args[1];
                    await checkSpeedBoostStatus(msg, user, sender, true, targetUserId);
                } else {
                    await checkSpeedBoostStatus(msg, user, sender, true);
                }
            } else {
                await checkSpeedBoostStatus(msg, user, sender, false);
            }
            break;
        }
        
        case 'REQUEST_SPEED_BOOST': {
            // Request new speed boost
            const user = findUserByPhone(senderNumber);
            if (!user) {
                await reply('‚ùå Maaf, nomor Anda tidak terdaftar dalam sistem.');
                break;
            }
            
            await handleSpeedBoostRequest(msg, user, sender);
            break;
        }
        
        case 'CLEAR_SPEED_BOOST': {
            // Clear speed boost status (admin only)
            if (!isAdmin(sender)) {
                await reply('‚ùå Perintah ini hanya untuk admin.');
                break;
            }
            
            // Extract user ID from command
            const args = chats.split(' ');
            if (args.length < 2) {
                await reply('üìù *Format:* clearspeed [user_id]\n\nContoh: clearspeed 1');
                break;
            }
            
            const targetUserId = args[1];
            const targetUser = global.users?.find(u => u.id == targetUserId);
            
            if (!targetUser) {
                await reply(`‚ùå User dengan ID ${targetUserId} tidak ditemukan.`);
                break;
            }
            
            await clearSpeedBoostStatus(msg, targetUser, sender, targetUserId);
            break;
        }

        case 'GANTI_POWER_WIFI': {
            const result = await handleWifiPowerChange({
                sender,
                pushname,
                entities,
                args,
                isOwner,
                isTeknisi,
                reply
            });
            
            if (result.message) {
                reply(result.message);
            }
            break;
        }

        case 'REBOOT_MODEM': {
            const result = await handleRouterReboot({
                sender,
                pushname,
                entities,
                args,
                isOwner,
                isTeknisi
            });
            
            if (result.message) {
                reply(result.message);
            }
            break;
        }

        // === CUSTOMER FEATURES ===
        case 'CEK_TAGIHAN': {
            const user = findUserByPhone(sender);
            const result = handleCheckBill({ user, pushname });
            reply(result.message);
            break;
        }

        case 'CEK_PAKET': {
            const user = findUserByPhone(sender);
            const result = handleCheckPackage({ user, pushname });
            reply(result.message);
            break;
        }

        case 'KELUHAN_SARAN': {
            const user = findUserByPhone(sender);
            const result = handleComplaint({ 
                user, 
                pushname, 
                complaint: q || entities.keluhan 
            });
            reply(result.message);
            break;
        }

        case 'INFO_LAYANAN': {
            const result = handleServiceInfo();
            reply(result.message);
            break;
        }

        // === MENUS ===
        case 'MENU_UTAMA':
        case 'help':
        case 'menu wifi':
        case 'menuwifi': {
            reply(wifimenu(global.config.nama, global.config.namabot));
            break;
        }

        case 'MENU_PELANGGAN':
        case 'menupelanggan': {
            const user = findUserByPhone(sender);
            if (!user) return reply(mess.userNotRegister);
            reply(customermenu(global.config.nama, global.config.namabot));
            break;
        }

        case 'MENU_TEKNISI': {
            if (!isTeknisi && !isOwner) return reply(mess.teknisiOnly);
            reply(techinisionmenu(global.config.nama, global.config.namabot));
            break;
        }

        case 'MENU_OWNER': {
            if (!isOwner) return reply(mess.owner);
            reply(menuowner(global.config.nama, global.config.namabot));
            break;
        }

        // === GREETINGS ===
        case 'SAPAAN_UMUM':
        case 'hallo':
        case 'halo':
        case 'hi':
        case 'hai':
        case 'min':
        case 'kak':
        case 'mas': {
            const hour = new Date().getHours();
            let greeting = hour < 12 ? 'Selamat pagi' : hour < 18 ? 'Selamat siang' : 'Selamat malam';
            reply(`${greeting} ${pushname}! üëã\n\nAda yang bisa saya bantu? Ketik *menu* untuk melihat daftar layanan yang tersedia.`);
            break;
        }

        // === BANTUAN ===
        case 'BANTUAN': {
            reply(`üìö *Panduan Penggunaan Bot*\n\n*Perintah Umum:*\n‚Ä¢ menu - Tampilkan menu utama\n‚Ä¢ lapor - Laporkan gangguan\n‚Ä¢ cektiket [ID] - Cek status tiket\n‚Ä¢ cekwifi - Cek informasi WiFi\n\n*Perintah Pelanggan:*\n‚Ä¢ gantinama - Ganti nama WiFi\n‚Ä¢ gantisandi - Ganti password WiFi\n‚Ä¢ reboot - Restart modem\n\nButuh bantuan lebih lanjut? Hubungi admin.`);
            break;
        }
        
        case 'TUTORIAL_TOPUP': {
            reply(menubelivoucher(global.config.nama, global.config.namabot));
            break;
        }
        
        case 'TANYA_CARA_PASANG': {
            reply(menupasang(global.config.nama, global.config.namabot));
            break;
        }
        
        case 'TANYA_PAKET_BULANAN': {
            reply(menupaket(global.config.nama, global.config.namabot));
            break;
        }
        
        case 'listprofstatik': {
            if (!isOwner) return reply(mess.owner);
            if (!global.statik || global.statik.length === 0) {
                return reply('Tidak ada profile statik tersedia.');
            }
            let profileList = '*LIST PROFILE STATIK*\n\n';
            global.statik.forEach((s, i) => {
                profileList += `${i + 1}. ${s.namastatik}\n`;
                profileList += `   Limit At: ${s.limitat}\n`;
                profileList += `   Max Limit: ${s.maxlimit}\n\n`;
            });
            reply(profileList);
            break;
        }
        
        case 'listprofvoucher': {
            if (!isOwner) return reply(mess.owner);
            if (!global.voucher || global.voucher.length === 0) {
                return reply('Tidak ada profile voucher tersedia.');
            }
            let voucherList = '*LIST PROFILE VOUCHER*\n\n';
            global.voucher.forEach((v, i) => {
                voucherList += `${i + 1}. ${v.namavc}\n`;
                voucherList += `   Harga: Rp. ${v.hargavc}\n`;
                voucherList += `   Profile: ${v.profvc}\n`;
                voucherList += `   Durasi: ${v.durasivc}\n\n`;
            });
            reply(voucherList);
            break;
        }

        // === SALDO & PAYMENT ===
        case 'CEK_SALDO':
        case 'saldo':
        case 'ceksaldo':
        case 'cek saldo':
        case 'infosaldo':
        case 'info saldo':
        case 'saldo saya': {
            // Don't require user registration for saldo check
            await handleCekSaldo(msg, sender, reply, pushname);
            break;
        }

        case 'TOPUP_SALDO':
        case 'topup':
        case 'top up':
        case 'isi saldo':
        case 'tambah saldo':
        case 'topup saldo':
        case 'buynow': {
            // Allow topup for all users, not just registered customers
            await handleTopupInit(msg, sender, reply, pushname, conversationHandler);
            break;
        }
        
        case 'batal topup':
        case 'cancel topup':
        case 'batalkan topup': {
            // This case should not be reached because we handle it earlier
            // But keep it as fallback
            await handleCancelTopup(msg, sender, reply);
            break;
        }
        
        case 'BELI_VOUCHER':
        case 'beli voucher':
        case 'belivoucher':
        case 'buy voucher':
        case 'voucher': {
            // Allow voucher purchase for all users
            await handleBeliVoucher(msg, sender, reply, pushname);
            break;
        }
        
        case 'transfer': {
            // Use cleaned args that exclude the "transfer" keyword
            await handleTransferSaldo(msg, sender, reply, argsClean);
            break;
        }
        
        // Agent commands
        case 'agent':
        case 'agen':
        case 'outlet':
        case 'daftar agent':
        case 'list agent': {
            // Check if user specified an area (skip first arg which is the command itself)
            const area = args.slice(1).join(' ').trim();
            if (area) {
                await handleAgentByArea(msg, sender, reply, area);
            } else {
                await handleListAgents(msg, sender, reply, pushname);
            }
            break;
        }
        
        case 'layanan agent':
        case 'agent service':
        case 'layanan': {
            await handleAgentServices(msg, sender, reply);
            break;
        }
        
        case 'cari agent':
        case 'search agent':
        case 'cari agen': {
            const query = args.join(' ').trim();
            await handleSearchAgent(msg, sender, reply, query);
            break;
        }
        
        // Agent transaction commands
        case 'konfirmasi':
        case 'confirm':
        case 'konfirmasi topup': {
            // Args: [transaction_id, pin]
            const transactionArgs = args.slice(1); // Remove command word
            await handleAgentConfirmation(msg, sender, reply, transactionArgs);
            break;
        }
        
        case 'transaksi hari ini':
        case 'transaksi hariini':
        case 'today transactions':
        case 'transaksi':
        case 'my transactions': {
            await handleAgentTodayTransactions(msg, sender, reply);
            break;
        }
        
        case 'check_topup_status':  // ‚úÖ Intent from commands.json
        case 'cek topup':            // Fallback literal keyword
        case 'check topup':
        case 'status topup': {
            // Auto-detect pending topup by user number (no ID needed)
            await handleCheckTopupStatus(msg, sender, reply);
            break;
        }
        
        // Agent self-service commands
        case 'ganti pin':
        case 'agent_change_pin': {
            await handleAgentPinChange(msg, sender, reply, args);
            break;
        }
        
        case 'update alamat':
        case 'agent_update_address': {
            await handleAgentProfileUpdate(msg, sender, reply, args, 'address');
            break;
        }
        
        case 'update jam':
        case 'agent_update_hours': {
            await handleAgentProfileUpdate(msg, sender, reply, args, 'hours');
            break;
        }
        
        case 'update phone':
        case 'update telepon':
        case 'agent_update_phone': {
            await handleAgentProfileUpdate(msg, sender, reply, args, 'phone');
            break;
        }
        
        case 'tutup sementara':
        case 'close temporarily':
        case 'agent_close_temporarily': {
            await handleAgentStatusToggle(msg, sender, reply, 'close');
            break;
        }
        
        case 'buka kembali':
        case 'open again':
        case 'agent_open_again': {
            await handleAgentStatusToggle(msg, sender, reply, 'open');
            break;
        }
        
        case 'profil agent':
        case 'info agent':
        case 'agent info':
        case 'agent_view_profile': {
            await handleAgentSelfProfile(msg, sender, reply);
            break;
        }

        case 'TOPUP_SALDO_OLD':
        case 'buynow_old': {
            const user = findUserByPhone(sender);
            if (!user) return reply(mess.userNotRegister);
            
            // Set initial conversation state for topup
            setUserState(sender, {
                step: 'TOPUP_SELECT_METHOD',
                type: 'topup',
                timestamp: Date.now()
            });
            
            const topupMsg = `üí≥ *TOP UP SALDO*\n\n` +
                           `Silakan pilih metode pembayaran:\n\n` +
                           `1Ô∏è‚É£ Transfer Bank\n` +
                           `2Ô∏è‚É£ Cash (Bayar Tunai)\n\n` +
                           `Balas dengan angka pilihan Anda.\n` +
                           `Ketik *batal* untuk membatalkan.`;
            
            reply(topupMsg);
            break;
        }

        case 'allsaldo': {
            if (!isOwner) return reply(mess.owner);
            
            if (!global.saldo || global.saldo.length === 0) {
                return reply('Belum ada data saldo.');
            }
            
            let saldoList = '*DATA SALDO SEMUA USER*\n\n';
            global.saldo.forEach((s, i) => {
                saldoList += `${i + 1}. ${s.id}\nSaldo: ${convertRupiah.convert(s.saldo)}\n\n`;
            });
            
            reply(saldoList);
            break;
        }

        // === ADMIN MANAGEMENT ===
        case 'admin': {
            if (!isOwner) return reply(mess.owner);
            reply(`*Admin Management*\n\nGunakan perintah berikut:\n‚Ä¢ addadmin [nomor] - Tambah admin\n‚Ä¢ deladmin [nomor] - Hapus admin\n‚Ä¢ listadmin - Lihat daftar admin`);
            break;
        }

        // === DEFAULT CASE ===
        default: {
            if (intent === "TIDAK_DIKENALI") {
                // Do nothing to avoid spamming user conversations
                logger.debug('Unrecognized intent', { message: chats.substring(0, 50) });
            }
            break;
        }
    }
    } catch (error) {
        // Log error and send user-friendly message
        logger.error('Error processing message', {
            error: error,
            intent: intent,
            user: sender,
            message: chats.substring(0, 100)
        });
        
        trackError(ErrorType.SYSTEM, error, { 
            intent: intent,
            user: sender 
        });
        
        await sendErrorResponse(raf, from, error, null, {
            context: { intent: intent }
        });
    } finally {
        // Track performance
        const duration = messageTimer();
        
        // Log slow messages
        if (duration > 3000) {
            logger.warn('Slow message processing', {
                duration: duration,
                intent: intent,
                user: sender
            });
        }
    }
};
